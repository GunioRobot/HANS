#!/usr/bin/python
# -*- coding: utf-8 -*-
# vim: ts=4 
# vim: expandtab
###
#
# Copyright (c) 2011 David Amián
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors : David Amián <damian@emergya.com>
# 
###
import sys
import getopt
import logging
import string
import pynotify
import os
import re

import gettext
import gudev
from gettext import gettext as _
gettext.textdomain('hans')

# Add project root directory (enable symlink, and trunk execution).
PROJECT_ROOT_DIRECTORY = os.path.abspath(
    os.path.dirname(os.path.dirname(os.path.realpath(sys.argv[0]))))

if (os.path.exists(os.path.join(PROJECT_ROOT_DIRECTORY, 'hans'))
    and PROJECT_ROOT_DIRECTORY not in sys.path):
    sys.path.insert(0, PROJECT_ROOT_DIRECTORY)
    os.putenv('PYTHONPATH', PROJECT_ROOT_DIRECTORY) # for subprocesses


from hans import (DeviceEntry, NewDeviceEntry, InterfaceEntry)
from hans.utils import notify

HANS_PATH_DB=PROJECT_ROOT_DIRECTORY+'/db/'
TEXTBUFFER_LOGGER = 'hans-core'
LOG_LEVEL = logging.DEBUG
LOG_FORMAT = '%(asctime)s %(levelname)s - %(message)s'
LOG_DATE_FORMAT = '%H:%M:%S'


class HansCore():

    def __init__(self):
        self.gudev_client=gudev.Client('usb')

    def main(self,argvs):
        try:
            options, remainder = getopt.gnu_getopt(argvs, 't:p:d:c:', ['type=', 
                                                             'path=','devicetype=','deviceclass',
                                                             ])
        except getopt.GetoptError:
            usage()
            sys.exit(2)

        if not options:
            usage()
            sys.exit(2)
        
        if not pynotify.init("HANS notification"):
            sys.exit(1)

        opttype=False
        optpath=False
        optdevt=False
        optdevc=False

        for opt, arg in options:
            if opt in ('-t', '--type'):
                opttype=True
                self.utype = arg
            elif opt in ('-p', '--path'):
                optpath=True
                self.path_dev = arg
            elif opt in ('-d', '--devicetype'):
                optdevt=True
                self.dev_type = arg
            elif opt in ('-c', '--deviceclass'):
                optdevc=True
                self.dev_class = arg


        if not optpath and not opttype:
            print "[-t|--type] and [-p|--path] options is required"
            usage()
            sys.exit(2)
        
        if 


        if utype!='device' and utype!='interface':
            print "[-t|--type] argument must be 'device' or 'interface'"
            sys.exit(1)

        if utype='device':
            if not optpath:
                print "[-p|--path] option is required for deviceclass"
                usage()
                sys.exit(2)

            self.deviceClass=DeviceClass(self.path_dev)
            

        






    
    


        
        regexp = re.compile('x-usb-device/[a-z]+')
        if not regexp.match(self.dev_type):
            print "The device type must be x-usb-device/'name_of_device'"
            sys.exit(1)

        self.device = self.dev_type.split("/")[1]
#        if not self._checkDTavailable():
#            self._notify(self.device, _("The device '"+self.device+"' isn't controlled by HANS"))
#            print "Way to create new device_type and new udev rules (coding)"
#            sys.exit(0) #temporally, waiting for code
        
        self.filename_entry=HANS_PATH_DB+self.device+".device"
        if os.path.exists(self.filename_entry):
            self.dev_type_entry=DeviceEntry.DeviceEntry(self.filename_entry)
        else:
            self._notify(self.device, _("The device '"+self.device+"' hasn't associated entry file"))
            print "Way to create new entry for "+self.device+" by user (coding)"
            sys.exit(0) #temporally, waiting for code
        self._notify(self.dev_type_entry.getName(), self.dev_type_entry.getNotify())
   
#    def _checkDTavailable(self):
#        infile = open(HANS_DT_AVAILABLE, 'r')
#        hans_dt_available = list()
#        for line in infile:
#            hans_dt_available.append(line.strip('\n'))
#        infile.close()
#        if self.dev_type in hans_dt_available:
#            return True
#        else:
#            return False


    def _newDevice(self):
        new = NewDeviceEntry.NewDeviceEntry()
        response = new.run()
        new.destroy()
        sys.exit(0)
            


def usage():
    print "Usage: hans-core.py [-t|--type] [-p|--path] [-d|--devicetype] [-c|--deviceclass]" 

if __name__ == '__main__':
    hans=HansCore()
    hans.main(sys.argv[1:])
